Menu="Identification"
Title="SSL Certificate Settings"
Icon="ident.png"
Tag="expeditedssl"
---
<?PHP
/* Copyright 2005-2017, Lime Technology
 * Copyright 2012-2017, Bergware International.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version 2,
 * as published by the Free Software Foundation.
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 */
?>
<script>
function provisionSSL(internalip, keyfile, button) {
    $(button).prop("disabled", true).html("<i class=\"fa fa-spinner fa-spin\" aria-hidden=\"true\"></i> Provisioning");

    var failure = function(data) {
        var status = data.status;
        var obj = data.responseJSON;
        var msg = "Sorry, an error ("+status+") occurred provisioning your SSL certificate. " +
                  "The error is: "+obj.error+".";
        $(button).prop("disabled", false).html("Provision");
        swal("Oops",msg,"error");
    };

    $.post("https://keys.lime-technology.com/account/ssl/provisioncert",{internalip:internalip,keyfile:keyfile},function(data) {
        if (data.bundle) {
            $.get("//"+data.internal_dns+":<?=$var['PORT']?>/dnscheck",function() {
                $.post("/webGui/include/CertUpload.php",{text:data.bundle,csrf_token:"<?=$var['csrf_token']?>"},function(data) {
                    var msg = "Your Let's Encrypt SSL Certificate has been provisioned and a DNS record " +
                              "for local IP address "+internalip+" has been created on unraid.net.";
                    swal({title:"",text:msg,type:"success",allowEscapeKey:false},function(){button.form.submit();});
                }).fail(failure);
            }).fail(function(){
                failure({"status": 403, "responseJSON": {"error": "Your router or DNS server has DNS rebinding protection enabled, preventing "+data.internal_dns+" "+internalip+" resolution.  See Help for more details and workarounds"}});
            });
        } else {
            failure({"status": 403, "responseJSON": {"error": "Server was unable to provision SSL certificate"}});
        }
    }).fail(failure);
}

function updateDNS(internalip, keyfile, button) {
    $(button).prop("disabled", true).html("<i class=\"fa fa-spinner fa-spin\" aria-hidden=\"true\"></i> Updating DNS");

    var failure = function(data) {
        var status = data.status;
        var obj = data.responseJSON;
        var msg = "Sorry, an error ("+status+") occurred updating unraid.net DNS records. " +
                  "The error is: "+obj.error+".";
        $(button).prop("disabled", false).html("Update DNS");
        swal('Oops',msg,'error');
    };

    $.post("https://keys.lime-technology.com/account/ssl/updatedns",{internalip:internalip,keyfile:keyfile},function(data) {
        $(button).prop("disabled", false).html("Update DNS");
        swal("","Your local IP address "+internalip+" has been updated for unraid.net.","success");
    }).fail(failure);
}
</script>
<?
$keyfile = @file_get_contents($var['regFILE']);
if ($keyfile !== false)
  $keyfile = @base64_encode($keyfile);
$disabled = $keyfile===false || file_exists("/boot/config/ssl/certs/certificate_bundle.pem") || $var['USE_SSL']!="auto" ? 'disabled' : '';
$disabled_updatedns = $keyfile!==false && file_exists("/boot/config/ssl/certs/certificate_bundle.pem") ? '' : 'disabled';
?>
<form markdown="1" name="SSLSettings" method="POST" action="/update.htm" target="progressFrame">
Use SSL/TLS:
: <select name="USE_SSL" size="1" class="narrow">
  <?=mk_option($var['USE_SSL'], "auto", "Auto")?>
  <?=mk_option($var['USE_SSL'], "no", "No")?>
  <?=mk_option($var['USE_SSL'], "yes", "Yes")?>
  </select>

> Determines how the webGui responds to HTTP and/or HTTPS protocol.
>
> Select **No** to disable HTTPS (but HTTPS is recognized and redirected to HTTP).
>
> Select **Yes** to enable HTTPS and redirect HTTP to HTTPS.
>
> With **Auto** selected, behaves like **No** if only a self-signed SSL certificate is present.  If
> a Lets Encrypt or other user supplied SSL certificate if present, behavies like **Yes**.
>
> A self-signed SSL certificate is automatically generated during start-up in the
> file `/boot/config/ssl/certs/<hostname>_unraid_bundle.pem` if it does not already exist.
>
> A Lets Encrypt or other user-generated SSL certificate, must be stored in the
> file `/boot/config/ssl/csrts/certificate_bundle.pem`.  *nginx* will prefer ths certificate if present.

HTTP port:
: <input type="number" name="PORT" class="trim" min="0" max="65535" value="<?=htmlspecialchars($var['PORT'])?>">

> Enter the HTTP port, default is 80.

HTTPS port:
: <input type="number" name="PORTSSL" class="trim" min="0" max="65535" value="<?=htmlspecialchars($var['PORTSSL'])?>">

> Enter the HTTPS port, default is 443.

&nbsp;
: <input type="submit" name="changePorts" value="Apply"><input type="button" value="Done" onclick="done()">

</form>
<form markdown="1" name="Provision" method="POST" action="/update.htm" target="progressFrame">
<input type="hidden" name="changePorts" value="apply">
Certificate issuer:
: <?echo shell_exec("/usr/bin/openssl x509 -text -noout -in /etc/ssl/certs/unraid_bundle.pem|sed -n -e 's/^.*Issuer: //p'")?>

Certificate expiration:
: <?echo shell_exec("/usr/bin/openssl x509 -text -noout -in /etc/ssl/certs/unraid_bundle.pem|sed -n -e 's/^.*Not After : //p'")?>

&nbsp;
: <button type="button" onclick="provisionSSL('<?=$eth0['IPADDR:0']?>', '<?=$keyfile?>', this)" <?=$disabled?>>Provision</button><button type="button" disabled>Renew</button><button type="button" onclick="updateDNS('<?=$eth0['IPADDR:0']?>', '<?=$keyfile?>', this)" <?=$disabled_updatedns?>>Update DNS</button>

> **Provision** may be used to allocate a *free* SSL Certficiate from [Let's Encrypt](https://letsencrypt.org/) and
> then upload to your server.  Note: We **highly** recommend using a static IP address in this case.

> **Update DNS** may be used to manually initiate updating the DNS A-record of your server FQDN on unraid.net.  Note
> that DNS propagation change could take anywhere from 1 minute to several hours (we set TTL to 60 seconds).

> Note: **Provision** may fail if your router or upstream DNS server has
> [DNS rebinding protection](https://en.wikipedia.org/wiki/DNS_rebinding) enabled.  DNS rebinding
> protection prevents DNS from resolving a private IP network range.  DNS rebinding protection is meant as
> a security feature on a local LAN which includes legacy devices with buggy/insecure "web" interfaces.

> One source of DNS rebinding protection could be your ISP DNS server.  In this case the problem may be solved by
> switching to a different DNS server such as Google's public DNS.

> More commonly, DNS rebinding protection could be enabled in your router.  Most consumer routers do not implement DNS
> rebinding protection; but, if they do, a configuration setting should be available to turn it off.

> Higher end routers usually do enable DNS rebinding protection however.  Typically there are ways of turning it off
> entirely or selectively based on domain.  Examples:

> **DD-WRT:** If you are using "dnsmasq" with DNS rebinding protection enabled, you can add this line to your router
> configuration file:

> `rebind-domain-ok=/unraid.net/`

> **pfSense:** If you are using pfSense internal DNS resolver service, you can add these Custom Option lines:

> `server:`<br>
> `private-domain: "unraid.net"`

> **Ubiquiti USG router:** you can add this configuration line:

> `set service dns forwarding options rebind-domain-ok=/unraid.net/`

> **OpenDNS:** Go to Settings -> Security and *remove* the checkbox next to
>  "Suspicious Responses - Block internal IP addresses". It is an all-or-nothing setting.

> When all else fails, you can create an entry in your PC's *hosts* file to override external DNS and
> directly resolve your servers unraid.net FQDN to its local IP address.

</form>
